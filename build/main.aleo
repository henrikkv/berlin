import zk_deck_shuffle.aleo;
import zk_sra_encryption.aleo;
import credits.aleo;
program war_game.aleo;

record Keys:
    owner as address.private;
    e as u128.private;
    d as u128.private;
    n as u128.private;

struct Game:
    player1 as address;
    player2 as address;
    cards_p1 as [u128; 14u32];
    cards_p2 as [u128; 14u32];
    chips_p1 as i8;
    chips_p2 as i8;
    turn as u8;
    war as u8;
    remaining_cards_p1 as u8;
    remaining_cards_p2 as u8;
    first_move_done as boolean;
    p1_must_reveal_p1 as boolean;
    p1_must_reveal_p2 as boolean;
    p2_must_reveal_p2 as boolean;
    p2_must_reveal_p1 as boolean;
    must_compare as boolean;
    winner as u8;

mapping games:
    key as u32.public;
    value as Game.public;

function create_game:
    input r0 as u32.private;
    input r1 as i8.private;
    input r2 as i8.private;
    input r3 as i8.private;
    input r4 as u128.private;
    input r5 as u128.private;
    input r6 as u128.private;
    cast 1u128 2u128 3u128 4u128 5u128 6u128 7u128 8u128 9u128 10u128 11u128 12u128 13u128 14u128 into r7 as [u128; 14u32];
    cast 15u128 16u128 17u128 18u128 19u128 20u128 21u128 22u128 23u128 24u128 25u128 26u128 27u128 28u128 into r8 as [u128; 14u32];
    cast r7 r8 into r9 as [[u128; 14u32]; 2u32];
    call zk_sra_encryption.aleo/encrypt_deck r4 r6 r9 into r10;
    call zk_deck_shuffle.aleo/full_shuffle r1 r2 r3 r10 into r11;
    cast self.caller r4 r5 r6 into r12 as Keys.record;
    call credits.aleo/transfer_public_as_signer self.signer 10000000u64 into r13;
    async create_game r0 r11 self.caller r13 into r14;
    output r12 as Keys.record;
    output r14 as war_game.aleo/create_game.future;

finalize create_game:
    input r0 as u32.public;
    input r1 as [[u128; 14u32]; 2u32].public;
    input r2 as address.public;
    input r3 as credits.aleo/transfer_public_as_signer.future;
    await r3;
    cast r2 aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc r1[0u32] r1[1u32] 32i8 32i8 0u8 1u8 14u8 14u8 false false false false false false 0u8 into r4 as Game;
    set r4 into games[r0];

function join_game:
    input r0 as u32.private;
    input r1 as [[u128; 14u32]; 2u32].private;
    input r2 as i8.private;
    input r3 as i8.private;
    input r4 as i8.private;
    input r5 as u128.private;
    input r6 as u128.private;
    input r7 as u128.private;
    call zk_sra_encryption.aleo/encrypt_deck r5 r7 r1 into r8;
    call zk_deck_shuffle.aleo/full_shuffle r2 r3 r4 r8 into r9;
    cast self.caller r5 r6 r7 into r10 as Keys.record;
    call credits.aleo/transfer_public_as_signer self.signer 10000000u64 into r11;
    async join_game r0 r1 r9 self.caller r11 into r12;
    output r10 as Keys.record;
    output r12 as war_game.aleo/join_game.future;

finalize join_game:
    input r0 as u32.public;
    input r1 as [[u128; 14u32]; 2u32].public;
    input r2 as [[u128; 14u32]; 2u32].public;
    input r3 as address.public;
    input r4 as credits.aleo/transfer_public_as_signer.future;
    await r4;
    get games[r0] into r5;
    is.eq r5.cards_p1 r1[0u32] into r6;
    assert.eq r6 true;
    is.eq r5.cards_p2 r1[1u32] into r7;
    assert.eq r7 true;
    cast r5.player1 r3 r2[0u32] r2[1u32] r5.chips_p1 r5.chips_p2 1u8 1u8 r5.remaining_cards_p1 r5.remaining_cards_p2 false false false false false false 0u8 into r8 as Game;
    set r8 into games[r0];

function bet:
    input r0 as u32.private;
    async bet r0 self.caller into r1;
    output r1 as war_game.aleo/bet.future;

finalize bet:
    input r0 as u32.public;
    input r1 as address.public;
    get games[r0] into r2;
    mod r2.turn 2u8 into r3;
    is.eq r3 1u8 into r4;
    is.eq r1 r2.player2 into r5;
    and r4 r5 into r6;
    not r4 into r7;
    is.eq r1 r2.player1 into r8;
    and r7 r8 into r9;
    or r6 r9 into r10;
    is.eq r1 r2.player1 into r11;
    and r4 r11 into r12;
    not r4 into r13;
    is.eq r1 r2.player2 into r14;
    and r13 r14 into r15;
    or r12 r15 into r16;
    ternary r2.first_move_done r10 r16 into r17;
    assert.eq r17 true;
    not r2.must_compare into r18;
    assert.eq r18 true;
    cast r2.player1 r2.player2 r2.cards_p1 r2.cards_p2 r2.chips_p1 r2.chips_p2 r2.turn r2.war r2.remaining_cards_p1 r2.remaining_cards_p2 true r2.first_move_done r2.first_move_done r2.first_move_done r2.first_move_done false 0u8 into r19 as Game;
    set r19 into games[r0];

function fold:
    input r0 as u32.private;
    async fold r0 self.caller into r1;
    output r1 as war_game.aleo/fold.future;

finalize fold:
    input r0 as u32.public;
    input r1 as address.public;
    get games[r0] into r2;
    mod r2.turn 2u8 into r3;
    is.eq r3 1u8 into r4;
    is.eq r1 r2.player1 into r5;
    and r4 r5 into r6;
    not r4 into r7;
    is.eq r1 r2.player2 into r8;
    and r7 r8 into r9;
    or r6 r9 into r10;
    is.eq r1 r2.player2 into r11;
    and r4 r11 into r12;
    not r4 into r13;
    is.eq r1 r2.player1 into r14;
    and r13 r14 into r15;
    or r12 r15 into r16;
    ternary r2.first_move_done r10 r16 into r17;
    assert.eq r17 true;
    not r2.must_compare into r18;
    assert.eq r18 true;
    is.eq r1 r2.player1 into r19;
    cast r2.war into r20 as i8;
    sub r20 1i8 into r21;
    mul r21 2i8 into r22;
    add r22 1i8 into r23;
    sub r2.chips_p1 r23 into r24;
    cast r2.war into r25 as i8;
    sub r25 1i8 into r26;
    mul r26 2i8 into r27;
    add r2.chips_p1 r27 into r28;
    add r28 1i8 into r29;
    ternary r19 r24 r29 into r30;
    is.eq r1 r2.player2 into r31;
    cast r2.war into r32 as i8;
    sub r32 1i8 into r33;
    mul r33 2i8 into r34;
    add r34 1i8 into r35;
    sub r2.chips_p2 r35 into r36;
    cast r2.war into r37 as i8;
    sub r37 1i8 into r38;
    mul r38 2i8 into r39;
    add r2.chips_p2 r39 into r40;
    add r40 1i8 into r41;
    ternary r31 r36 r41 into r42;
    add r2.turn 1u8 into r43;
    is.eq r1 r2.player2 into r44;
    and r4 r44 into r45;
    sub r2.remaining_cards_p1 1u8 into r46;
    ternary r45 r46 r2.remaining_cards_p1 into r47;
    not r4 into r48;
    is.eq r1 r2.player1 into r49;
    and r48 r49 into r50;
    sub r2.remaining_cards_p2 1u8 into r51;
    ternary r50 r51 r2.remaining_cards_p2 into r52;
    not r4 into r53;
    is.eq r1 r2.player1 into r54;
    and r53 r54 into r55;
    ternary r55 true false into r56;
    is.eq r1 r2.player2 into r57;
    and r4 r57 into r58;
    ternary r58 true false into r59;
    cast r2.player1 r2.player2 r2.cards_p1 r2.cards_p2 r30 r42 r43 1u8 r47 r52 false false r56 false r59 false 0u8 into r60 as Game;
    set r60 into games[r0];

function p1_reveal_p2:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as Keys.record;
    call zk_sra_encryption.aleo/decrypt_card r2.d r2.n r1 into r3;
    async p1_reveal_p2 r0 self.caller r1 r3 into r4;
    cast r2.owner r2.e r2.d r2.n into r5 as Keys.record;
    output r5 as Keys.record;
    output r4 as war_game.aleo/p1_reveal_p2.future;

finalize p1_reveal_p2:
    input r0 as u32.public;
    input r1 as address.public;
    input r2 as u128.public;
    input r3 as u128.public;
    get games[r0] into r4;
    is.eq r4.remaining_cards_p2 14u8 into r5;
    is.eq r4.remaining_cards_p2 13u8 into r6;
    is.eq r4.remaining_cards_p2 12u8 into r7;
    is.eq r4.remaining_cards_p2 11u8 into r8;
    is.eq r4.remaining_cards_p2 10u8 into r9;
    is.eq r4.remaining_cards_p2 9u8 into r10;
    is.eq r4.remaining_cards_p2 8u8 into r11;
    is.eq r4.remaining_cards_p2 7u8 into r12;
    is.eq r4.remaining_cards_p2 6u8 into r13;
    is.eq r4.remaining_cards_p2 5u8 into r14;
    is.eq r4.remaining_cards_p2 4u8 into r15;
    is.eq r4.remaining_cards_p2 3u8 into r16;
    is.eq r4.remaining_cards_p2 2u8 into r17;
    ternary r17 r4.cards_p2[1u32] r4.cards_p2[0u32] into r18;
    ternary r16 r4.cards_p2[2u32] r18 into r19;
    ternary r15 r4.cards_p2[3u32] r19 into r20;
    ternary r14 r4.cards_p2[4u32] r20 into r21;
    ternary r13 r4.cards_p2[5u32] r21 into r22;
    ternary r12 r4.cards_p2[6u32] r22 into r23;
    ternary r11 r4.cards_p2[7u32] r23 into r24;
    ternary r10 r4.cards_p2[8u32] r24 into r25;
    ternary r9 r4.cards_p2[9u32] r25 into r26;
    ternary r8 r4.cards_p2[10u32] r26 into r27;
    ternary r7 r4.cards_p2[11u32] r27 into r28;
    ternary r6 r4.cards_p2[12u32] r28 into r29;
    ternary r5 r4.cards_p2[13u32] r29 into r30;
    is.eq r1 r4.player1 into r31;
    assert.eq r31 true;
    is.eq r2 r30 into r32;
    assert.eq r32 true;
    is.eq r4.p1_must_reveal_p2 true into r33;
    assert.eq r33 true;
    is.eq r4.remaining_cards_p2 1u8 into r34;
    ternary r34 r3 r4.cards_p2[0u32] into r35;
    is.eq r4.remaining_cards_p2 2u8 into r36;
    ternary r36 r3 r4.cards_p2[1u32] into r37;
    is.eq r4.remaining_cards_p2 3u8 into r38;
    ternary r38 r3 r4.cards_p2[2u32] into r39;
    is.eq r4.remaining_cards_p2 4u8 into r40;
    ternary r40 r3 r4.cards_p2[3u32] into r41;
    is.eq r4.remaining_cards_p2 5u8 into r42;
    ternary r42 r3 r4.cards_p2[4u32] into r43;
    is.eq r4.remaining_cards_p2 6u8 into r44;
    ternary r44 r3 r4.cards_p2[5u32] into r45;
    is.eq r4.remaining_cards_p2 7u8 into r46;
    ternary r46 r3 r4.cards_p2[6u32] into r47;
    is.eq r4.remaining_cards_p2 8u8 into r48;
    ternary r48 r3 r4.cards_p2[7u32] into r49;
    is.eq r4.remaining_cards_p2 9u8 into r50;
    ternary r50 r3 r4.cards_p2[8u32] into r51;
    is.eq r4.remaining_cards_p1 10u8 into r52;
    ternary r52 r3 r4.cards_p2[9u32] into r53;
    is.eq r4.remaining_cards_p2 11u8 into r54;
    ternary r54 r3 r4.cards_p2[10u32] into r55;
    is.eq r4.remaining_cards_p2 12u8 into r56;
    ternary r56 r3 r4.cards_p2[11u32] into r57;
    is.eq r4.remaining_cards_p2 13u8 into r58;
    ternary r58 r3 r4.cards_p2[12u32] into r59;
    is.eq r4.remaining_cards_p2 14u8 into r60;
    ternary r60 r3 r4.cards_p2[13u32] into r61;
    cast r35 r37 r39 r41 r43 r45 r47 r49 r51 r53 r55 r57 r59 r61 into r62 as [u128; 14u32];
    not r4.p1_must_reveal_p1 into r63;
    not r4.p2_must_reveal_p2 into r64;
    and r63 r64 into r65;
    not r4.p2_must_reveal_p1 into r66;
    and r65 r66 into r67;
    cast r4.player1 r4.player2 r4.cards_p1 r62 r4.chips_p1 r4.chips_p2 r4.turn r4.war r4.remaining_cards_p1 r4.remaining_cards_p2 true r4.p1_must_reveal_p1 false r4.p2_must_reveal_p2 r4.p2_must_reveal_p1 r67 0u8 into r68 as Game;
    set r68 into games[r0];

function p1_reveal_p1:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as Keys.record;
    call zk_sra_encryption.aleo/decrypt_card r2.d r2.n r1 into r3;
    async p1_reveal_p1 r0 self.caller r1 r3 into r4;
    cast r2.owner r2.e r2.d r2.n into r5 as Keys.record;
    output r5 as Keys.record;
    output r4 as war_game.aleo/p1_reveal_p1.future;

finalize p1_reveal_p1:
    input r0 as u32.public;
    input r1 as address.public;
    input r2 as u128.public;
    input r3 as u128.public;
    get games[r0] into r4;
    is.eq r4.remaining_cards_p1 14u8 into r5;
    is.eq r4.remaining_cards_p1 13u8 into r6;
    is.eq r4.remaining_cards_p1 12u8 into r7;
    is.eq r4.remaining_cards_p1 11u8 into r8;
    is.eq r4.remaining_cards_p1 10u8 into r9;
    is.eq r4.remaining_cards_p1 9u8 into r10;
    is.eq r4.remaining_cards_p1 8u8 into r11;
    is.eq r4.remaining_cards_p1 7u8 into r12;
    is.eq r4.remaining_cards_p1 6u8 into r13;
    is.eq r4.remaining_cards_p1 5u8 into r14;
    is.eq r4.remaining_cards_p1 4u8 into r15;
    is.eq r4.remaining_cards_p1 3u8 into r16;
    is.eq r4.remaining_cards_p1 2u8 into r17;
    ternary r17 r4.cards_p1[1u32] r4.cards_p1[0u32] into r18;
    ternary r16 r4.cards_p1[2u32] r18 into r19;
    ternary r15 r4.cards_p1[3u32] r19 into r20;
    ternary r14 r4.cards_p1[4u32] r20 into r21;
    ternary r13 r4.cards_p1[5u32] r21 into r22;
    ternary r12 r4.cards_p1[6u32] r22 into r23;
    ternary r11 r4.cards_p1[7u32] r23 into r24;
    ternary r10 r4.cards_p1[8u32] r24 into r25;
    ternary r9 r4.cards_p1[9u32] r25 into r26;
    ternary r8 r4.cards_p1[10u32] r26 into r27;
    ternary r7 r4.cards_p1[11u32] r27 into r28;
    ternary r6 r4.cards_p1[12u32] r28 into r29;
    ternary r5 r4.cards_p1[13u32] r29 into r30;
    is.eq r1 r4.player1 into r31;
    assert.eq r31 true;
    is.eq r2 r30 into r32;
    assert.eq r32 true;
    is.eq r4.p1_must_reveal_p1 true into r33;
    assert.eq r33 true;
    is.eq r4.remaining_cards_p1 1u8 into r34;
    ternary r34 r3 r4.cards_p1[0u32] into r35;
    is.eq r4.remaining_cards_p1 2u8 into r36;
    ternary r36 r3 r4.cards_p1[1u32] into r37;
    is.eq r4.remaining_cards_p1 3u8 into r38;
    ternary r38 r3 r4.cards_p1[2u32] into r39;
    is.eq r4.remaining_cards_p1 4u8 into r40;
    ternary r40 r3 r4.cards_p1[3u32] into r41;
    is.eq r4.remaining_cards_p1 5u8 into r42;
    ternary r42 r3 r4.cards_p1[4u32] into r43;
    is.eq r4.remaining_cards_p1 6u8 into r44;
    ternary r44 r3 r4.cards_p1[5u32] into r45;
    is.eq r4.remaining_cards_p1 7u8 into r46;
    ternary r46 r3 r4.cards_p1[6u32] into r47;
    is.eq r4.remaining_cards_p1 8u8 into r48;
    ternary r48 r3 r4.cards_p1[7u32] into r49;
    is.eq r4.remaining_cards_p1 9u8 into r50;
    ternary r50 r3 r4.cards_p1[8u32] into r51;
    is.eq r4.remaining_cards_p1 10u8 into r52;
    ternary r52 r3 r4.cards_p1[9u32] into r53;
    is.eq r4.remaining_cards_p1 11u8 into r54;
    ternary r54 r3 r4.cards_p1[10u32] into r55;
    is.eq r4.remaining_cards_p1 12u8 into r56;
    ternary r56 r3 r4.cards_p1[11u32] into r57;
    is.eq r4.remaining_cards_p1 13u8 into r58;
    ternary r58 r3 r4.cards_p1[12u32] into r59;
    is.eq r4.remaining_cards_p1 14u8 into r60;
    ternary r60 r3 r4.cards_p1[13u32] into r61;
    cast r35 r37 r39 r41 r43 r45 r47 r49 r51 r53 r55 r57 r59 r61 into r62 as [u128; 14u32];
    not r4.p1_must_reveal_p2 into r63;
    not r4.p2_must_reveal_p2 into r64;
    and r63 r64 into r65;
    not r4.p2_must_reveal_p1 into r66;
    and r65 r66 into r67;
    cast r4.player1 r4.player2 r62 r4.cards_p2 r4.chips_p1 r4.chips_p2 r4.turn r4.war r4.remaining_cards_p1 r4.remaining_cards_p2 true false r4.p1_must_reveal_p2 r4.p2_must_reveal_p2 r4.p2_must_reveal_p1 r67 0u8 into r68 as Game;
    set r68 into games[r0];

function p2_reveal_p1:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as Keys.record;
    call zk_sra_encryption.aleo/decrypt_card r2.d r2.n r1 into r3;
    async p2_reveal_p1 r0 self.caller r1 r3 into r4;
    cast r2.owner r2.e r2.d r2.n into r5 as Keys.record;
    output r5 as Keys.record;
    output r4 as war_game.aleo/p2_reveal_p1.future;

finalize p2_reveal_p1:
    input r0 as u32.public;
    input r1 as address.public;
    input r2 as u128.public;
    input r3 as u128.public;
    get games[r0] into r4;
    is.eq r4.remaining_cards_p1 14u8 into r5;
    is.eq r4.remaining_cards_p1 13u8 into r6;
    is.eq r4.remaining_cards_p1 12u8 into r7;
    is.eq r4.remaining_cards_p1 11u8 into r8;
    is.eq r4.remaining_cards_p1 10u8 into r9;
    is.eq r4.remaining_cards_p1 9u8 into r10;
    is.eq r4.remaining_cards_p1 8u8 into r11;
    is.eq r4.remaining_cards_p1 7u8 into r12;
    is.eq r4.remaining_cards_p1 6u8 into r13;
    is.eq r4.remaining_cards_p1 5u8 into r14;
    is.eq r4.remaining_cards_p1 4u8 into r15;
    is.eq r4.remaining_cards_p1 3u8 into r16;
    is.eq r4.remaining_cards_p1 2u8 into r17;
    ternary r17 r4.cards_p1[1u32] r4.cards_p1[0u32] into r18;
    ternary r16 r4.cards_p1[2u32] r18 into r19;
    ternary r15 r4.cards_p1[3u32] r19 into r20;
    ternary r14 r4.cards_p1[4u32] r20 into r21;
    ternary r13 r4.cards_p1[5u32] r21 into r22;
    ternary r12 r4.cards_p1[6u32] r22 into r23;
    ternary r11 r4.cards_p1[7u32] r23 into r24;
    ternary r10 r4.cards_p1[8u32] r24 into r25;
    ternary r9 r4.cards_p1[9u32] r25 into r26;
    ternary r8 r4.cards_p1[10u32] r26 into r27;
    ternary r7 r4.cards_p1[11u32] r27 into r28;
    ternary r6 r4.cards_p1[12u32] r28 into r29;
    ternary r5 r4.cards_p1[13u32] r29 into r30;
    is.eq r1 r4.player2 into r31;
    assert.eq r31 true;
    is.eq r2 r30 into r32;
    assert.eq r32 true;
    is.eq r4.p2_must_reveal_p1 true into r33;
    assert.eq r33 true;
    is.eq r4.remaining_cards_p1 1u8 into r34;
    ternary r34 r3 r4.cards_p1[0u32] into r35;
    is.eq r4.remaining_cards_p1 2u8 into r36;
    ternary r36 r3 r4.cards_p1[1u32] into r37;
    is.eq r4.remaining_cards_p1 3u8 into r38;
    ternary r38 r3 r4.cards_p1[2u32] into r39;
    is.eq r4.remaining_cards_p1 4u8 into r40;
    ternary r40 r3 r4.cards_p1[3u32] into r41;
    is.eq r4.remaining_cards_p1 5u8 into r42;
    ternary r42 r3 r4.cards_p1[4u32] into r43;
    is.eq r4.remaining_cards_p1 6u8 into r44;
    ternary r44 r3 r4.cards_p1[5u32] into r45;
    is.eq r4.remaining_cards_p1 7u8 into r46;
    ternary r46 r3 r4.cards_p1[6u32] into r47;
    is.eq r4.remaining_cards_p1 8u8 into r48;
    ternary r48 r3 r4.cards_p1[7u32] into r49;
    is.eq r4.remaining_cards_p1 9u8 into r50;
    ternary r50 r3 r4.cards_p1[8u32] into r51;
    is.eq r4.remaining_cards_p1 10u8 into r52;
    ternary r52 r3 r4.cards_p1[9u32] into r53;
    is.eq r4.remaining_cards_p1 11u8 into r54;
    ternary r54 r3 r4.cards_p1[10u32] into r55;
    is.eq r4.remaining_cards_p1 12u8 into r56;
    ternary r56 r3 r4.cards_p1[11u32] into r57;
    is.eq r4.remaining_cards_p1 13u8 into r58;
    ternary r58 r3 r4.cards_p1[12u32] into r59;
    is.eq r4.remaining_cards_p1 14u8 into r60;
    ternary r60 r3 r4.cards_p1[13u32] into r61;
    cast r35 r37 r39 r41 r43 r45 r47 r49 r51 r53 r55 r57 r59 r61 into r62 as [u128; 14u32];
    not r4.p1_must_reveal_p1 into r63;
    not r4.p1_must_reveal_p2 into r64;
    and r63 r64 into r65;
    not r4.p2_must_reveal_p2 into r66;
    and r65 r66 into r67;
    cast r4.player1 r4.player2 r62 r4.cards_p2 r4.chips_p1 r4.chips_p2 r4.turn r4.war r4.remaining_cards_p1 r4.remaining_cards_p2 true r4.p1_must_reveal_p1 r4.p1_must_reveal_p2 r4.p2_must_reveal_p2 false r67 0u8 into r68 as Game;
    set r68 into games[r0];

function p2_reveal_p2:
    input r0 as u32.private;
    input r1 as u128.private;
    input r2 as Keys.record;
    call zk_sra_encryption.aleo/decrypt_card r2.d r2.n r1 into r3;
    async p2_reveal_p2 r0 self.caller r1 r3 into r4;
    cast r2.owner r2.e r2.d r2.n into r5 as Keys.record;
    output r5 as Keys.record;
    output r4 as war_game.aleo/p2_reveal_p2.future;

finalize p2_reveal_p2:
    input r0 as u32.public;
    input r1 as address.public;
    input r2 as u128.public;
    input r3 as u128.public;
    get games[r0] into r4;
    is.eq r4.remaining_cards_p2 14u8 into r5;
    is.eq r4.remaining_cards_p2 13u8 into r6;
    is.eq r4.remaining_cards_p2 12u8 into r7;
    is.eq r4.remaining_cards_p2 11u8 into r8;
    is.eq r4.remaining_cards_p2 10u8 into r9;
    is.eq r4.remaining_cards_p2 9u8 into r10;
    is.eq r4.remaining_cards_p2 8u8 into r11;
    is.eq r4.remaining_cards_p2 7u8 into r12;
    is.eq r4.remaining_cards_p2 6u8 into r13;
    is.eq r4.remaining_cards_p2 5u8 into r14;
    is.eq r4.remaining_cards_p2 4u8 into r15;
    is.eq r4.remaining_cards_p2 3u8 into r16;
    is.eq r4.remaining_cards_p2 2u8 into r17;
    ternary r17 r4.cards_p2[1u32] r4.cards_p2[0u32] into r18;
    ternary r16 r4.cards_p2[2u32] r18 into r19;
    ternary r15 r4.cards_p2[3u32] r19 into r20;
    ternary r14 r4.cards_p2[4u32] r20 into r21;
    ternary r13 r4.cards_p2[5u32] r21 into r22;
    ternary r12 r4.cards_p2[6u32] r22 into r23;
    ternary r11 r4.cards_p2[7u32] r23 into r24;
    ternary r10 r4.cards_p2[8u32] r24 into r25;
    ternary r9 r4.cards_p2[9u32] r25 into r26;
    ternary r8 r4.cards_p2[10u32] r26 into r27;
    ternary r7 r4.cards_p2[11u32] r27 into r28;
    ternary r6 r4.cards_p2[12u32] r28 into r29;
    ternary r5 r4.cards_p2[13u32] r29 into r30;
    is.eq r1 r4.player2 into r31;
    assert.eq r31 true;
    is.eq r2 r30 into r32;
    assert.eq r32 true;
    is.eq r4.p2_must_reveal_p2 true into r33;
    assert.eq r33 true;
    is.eq r4.remaining_cards_p2 1u8 into r34;
    ternary r34 r3 r4.cards_p2[0u32] into r35;
    is.eq r4.remaining_cards_p2 2u8 into r36;
    ternary r36 r3 r4.cards_p2[1u32] into r37;
    is.eq r4.remaining_cards_p2 3u8 into r38;
    ternary r38 r3 r4.cards_p2[2u32] into r39;
    is.eq r4.remaining_cards_p2 4u8 into r40;
    ternary r40 r3 r4.cards_p2[3u32] into r41;
    is.eq r4.remaining_cards_p2 5u8 into r42;
    ternary r42 r3 r4.cards_p2[4u32] into r43;
    is.eq r4.remaining_cards_p2 6u8 into r44;
    ternary r44 r3 r4.cards_p2[5u32] into r45;
    is.eq r4.remaining_cards_p2 7u8 into r46;
    ternary r46 r3 r4.cards_p2[6u32] into r47;
    is.eq r4.remaining_cards_p2 8u8 into r48;
    ternary r48 r3 r4.cards_p2[7u32] into r49;
    is.eq r4.remaining_cards_p2 9u8 into r50;
    ternary r50 r3 r4.cards_p2[8u32] into r51;
    is.eq r4.remaining_cards_p2 10u8 into r52;
    ternary r52 r3 r4.cards_p2[9u32] into r53;
    is.eq r4.remaining_cards_p2 11u8 into r54;
    ternary r54 r3 r4.cards_p2[10u32] into r55;
    is.eq r4.remaining_cards_p2 12u8 into r56;
    ternary r56 r3 r4.cards_p2[11u32] into r57;
    is.eq r4.remaining_cards_p2 13u8 into r58;
    ternary r58 r3 r4.cards_p2[12u32] into r59;
    is.eq r4.remaining_cards_p2 14u8 into r60;
    ternary r60 r3 r4.cards_p2[13u32] into r61;
    cast r35 r37 r39 r41 r43 r45 r47 r49 r51 r53 r55 r57 r59 r61 into r62 as [u128; 14u32];
    not r4.p1_must_reveal_p1 into r63;
    not r4.p1_must_reveal_p2 into r64;
    and r63 r64 into r65;
    not r4.p2_must_reveal_p1 into r66;
    and r65 r66 into r67;
    cast r4.player1 r4.player2 r4.cards_p1 r62 r4.chips_p1 r4.chips_p2 r4.turn r4.war r4.remaining_cards_p1 r4.remaining_cards_p2 true r4.p1_must_reveal_p1 r4.p1_must_reveal_p2 false r4.p2_must_reveal_p1 r67 0u8 into r68 as Game;
    set r68 into games[r0];

function compare_cards:
    input r0 as u32.private;
    async compare_cards r0 into r1;
    output r1 as war_game.aleo/compare_cards.future;

finalize compare_cards:
    input r0 as u32.public;
    get games[r0] into r1;
    not r1.p1_must_reveal_p1 into r2;
    assert.eq r2 true;
    not r1.p1_must_reveal_p2 into r3;
    assert.eq r3 true;
    not r1.p2_must_reveal_p2 into r4;
    assert.eq r4 true;
    not r1.p2_must_reveal_p1 into r5;
    assert.eq r5 true;
    assert.eq r1.must_compare true;
    is.eq r1.remaining_cards_p1 14u8 into r6;
    is.eq r1.remaining_cards_p1 13u8 into r7;
    is.eq r1.remaining_cards_p1 12u8 into r8;
    is.eq r1.remaining_cards_p1 11u8 into r9;
    is.eq r1.remaining_cards_p1 10u8 into r10;
    is.eq r1.remaining_cards_p1 9u8 into r11;
    is.eq r1.remaining_cards_p1 8u8 into r12;
    is.eq r1.remaining_cards_p1 7u8 into r13;
    is.eq r1.remaining_cards_p1 6u8 into r14;
    is.eq r1.remaining_cards_p1 5u8 into r15;
    is.eq r1.remaining_cards_p1 4u8 into r16;
    is.eq r1.remaining_cards_p1 3u8 into r17;
    is.eq r1.remaining_cards_p1 2u8 into r18;
    ternary r18 r1.cards_p1[1u32] r1.cards_p1[0u32] into r19;
    ternary r17 r1.cards_p1[2u32] r19 into r20;
    ternary r16 r1.cards_p1[3u32] r20 into r21;
    ternary r15 r1.cards_p1[4u32] r21 into r22;
    ternary r14 r1.cards_p1[5u32] r22 into r23;
    ternary r13 r1.cards_p1[6u32] r23 into r24;
    ternary r12 r1.cards_p1[7u32] r24 into r25;
    ternary r11 r1.cards_p1[8u32] r25 into r26;
    ternary r10 r1.cards_p1[9u32] r26 into r27;
    ternary r9 r1.cards_p1[10u32] r27 into r28;
    ternary r8 r1.cards_p1[11u32] r28 into r29;
    ternary r7 r1.cards_p1[12u32] r29 into r30;
    ternary r6 r1.cards_p1[13u32] r30 into r31;
    is.eq r1.remaining_cards_p2 14u8 into r32;
    is.eq r1.remaining_cards_p2 13u8 into r33;
    is.eq r1.remaining_cards_p2 12u8 into r34;
    is.eq r1.remaining_cards_p2 11u8 into r35;
    is.eq r1.remaining_cards_p2 10u8 into r36;
    is.eq r1.remaining_cards_p2 9u8 into r37;
    is.eq r1.remaining_cards_p2 8u8 into r38;
    is.eq r1.remaining_cards_p2 7u8 into r39;
    is.eq r1.remaining_cards_p2 6u8 into r40;
    is.eq r1.remaining_cards_p2 5u8 into r41;
    is.eq r1.remaining_cards_p2 4u8 into r42;
    is.eq r1.remaining_cards_p2 3u8 into r43;
    is.eq r1.remaining_cards_p2 2u8 into r44;
    ternary r44 r1.cards_p2[1u32] r1.cards_p2[0u32] into r45;
    ternary r43 r1.cards_p2[2u32] r45 into r46;
    ternary r42 r1.cards_p2[3u32] r46 into r47;
    ternary r41 r1.cards_p2[4u32] r47 into r48;
    ternary r40 r1.cards_p2[5u32] r48 into r49;
    ternary r39 r1.cards_p2[6u32] r49 into r50;
    ternary r38 r1.cards_p2[7u32] r50 into r51;
    ternary r37 r1.cards_p2[8u32] r51 into r52;
    ternary r36 r1.cards_p2[9u32] r52 into r53;
    ternary r35 r1.cards_p2[10u32] r53 into r54;
    ternary r34 r1.cards_p2[11u32] r54 into r55;
    ternary r33 r1.cards_p2[12u32] r55 into r56;
    ternary r32 r1.cards_p2[13u32] r56 into r57;
    gt r31 r57 into r58;
    gt r57 r31 into r59;
    cast r1.war into r60 as i8;
    mul r60 2i8 into r61;
    add r1.chips_p1 r61 into r62;
    cast r1.war into r63 as i8;
    mul r63 2i8 into r64;
    sub r1.chips_p1 r64 into r65;
    ternary r59 r65 r1.chips_p1 into r66;
    ternary r58 r62 r66 into r67;
    cast r1.war into r68 as i8;
    mul r68 2i8 into r69;
    add r1.chips_p2 r69 into r70;
    cast r1.war into r71 as i8;
    mul r71 2i8 into r72;
    sub r1.chips_p2 r72 into r73;
    ternary r58 r73 r1.chips_p2 into r74;
    ternary r59 r70 r74 into r75;
    sub r1.remaining_cards_p1 1u8 into r76;
    sub r1.remaining_cards_p2 1u8 into r77;
    lte r75 0i8 into r78;
    is.eq r77 0u8 into r79;
    or r78 r79 into r80;
    lte r67 0i8 into r81;
    is.eq r76 0u8 into r82;
    or r81 r82 into r83;
    ternary r83 2u8 0u8 into r84;
    ternary r80 1u8 r84 into r85;
    add r1.turn 1u8 into r86;
    or r58 r59 into r87;
    mul r1.war 2u8 into r88;
    ternary r87 1u8 r88 into r89;
    cast r1.player1 r1.player2 r1.cards_p1 r1.cards_p2 r67 r75 r86 r89 r76 r77 false false true false true false r85 into r90 as Game;
    set r90 into games[r0];

function claim_prize:
    input r0 as u32.private;
    call credits.aleo/transfer_public_as_signer self.caller 20000000u64 into r1;
    async claim_prize r0 self.caller r1 into r2;
    output r2 as war_game.aleo/claim_prize.future;

finalize claim_prize:
    input r0 as u32.public;
    input r1 as address.public;
    input r2 as credits.aleo/transfer_public_as_signer.future;
    get games[r0] into r3;
    is.eq r3.winner 1u8 into r4;
    is.eq r1 r3.player1 into r5;
    and r4 r5 into r6;
    is.eq r3.winner 2u8 into r7;
    is.eq r1 r3.player2 into r8;
    and r7 r8 into r9;
    or r6 r9 into r10;
    assert.eq r10 true;
    is.neq r3.winner 3u8 into r11;
    assert.eq r11 true;
    await r2;
    cast r3.player1 r3.player2 r3.cards_p1 r3.cards_p2 r3.chips_p1 r3.chips_p2 r3.turn r3.war r3.remaining_cards_p1 r3.remaining_cards_p2 r3.first_move_done r3.p1_must_reveal_p1 r3.p1_must_reveal_p2 r3.p2_must_reveal_p2 r3.p2_must_reveal_p1 r3.must_compare 3u8 into r12 as Game;
    set r12 into games[r0];

constructor:
    assert.eq edition 0u16;
