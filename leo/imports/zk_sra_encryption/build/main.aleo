program zk_sra_encryption.aleo;

closure exp_by_squaring:
    input r0 as u128;
    input r1 as u128;
    input r2 as u128;
    rem r1 2u128 into r3;
    is.eq r3 1u128 into r4;
    mul 1u128 r0 into r5;
    rem r5 r2 into r6;
    ternary r4 r6 1u128 into r7;
    mul r0 r0 into r8;
    rem r8 r2 into r9;
    shr r1 1u8 into r10;
    rem r10 2u128 into r11;
    is.eq r11 1u128 into r12;
    mul r7 r9 into r13;
    rem r13 r2 into r14;
    ternary r12 r14 r7 into r15;
    mul r9 r9 into r16;
    rem r16 r2 into r17;
    shr r10 1u8 into r18;
    rem r18 2u128 into r19;
    is.eq r19 1u128 into r20;
    mul r15 r17 into r21;
    rem r21 r2 into r22;
    ternary r20 r22 r15 into r23;
    mul r17 r17 into r24;
    rem r24 r2 into r25;
    shr r18 1u8 into r26;
    rem r26 2u128 into r27;
    is.eq r27 1u128 into r28;
    mul r23 r25 into r29;
    rem r29 r2 into r30;
    ternary r28 r30 r23 into r31;
    mul r25 r25 into r32;
    rem r32 r2 into r33;
    shr r26 1u8 into r34;
    rem r34 2u128 into r35;
    is.eq r35 1u128 into r36;
    mul r31 r33 into r37;
    rem r37 r2 into r38;
    ternary r36 r38 r31 into r39;
    mul r33 r33 into r40;
    rem r40 r2 into r41;
    shr r34 1u8 into r42;
    rem r42 2u128 into r43;
    is.eq r43 1u128 into r44;
    mul r39 r41 into r45;
    rem r45 r2 into r46;
    ternary r44 r46 r39 into r47;
    mul r41 r41 into r48;
    rem r48 r2 into r49;
    shr r42 1u8 into r50;
    rem r50 2u128 into r51;
    is.eq r51 1u128 into r52;
    mul r47 r49 into r53;
    rem r53 r2 into r54;
    ternary r52 r54 r47 into r55;
    mul r49 r49 into r56;
    rem r56 r2 into r57;
    shr r50 1u8 into r58;
    rem r58 2u128 into r59;
    is.eq r59 1u128 into r60;
    mul r55 r57 into r61;
    rem r61 r2 into r62;
    ternary r60 r62 r55 into r63;
    mul r57 r57 into r64;
    rem r64 r2 into r65;
    shr r58 1u8 into r66;
    cast r63 into r67 as u128;
    output r67 as u128;

function encrypt_deck:
    input r0 as u128.private;
    input r1 as u128.private;
    input r2 as [[u128; 14u32]; 2u32].private;
    call exp_by_squaring r2[0u32][0u32] r0 r1 into r3;
    call exp_by_squaring r2[0u32][1u32] r0 r1 into r4;
    call exp_by_squaring r2[0u32][2u32] r0 r1 into r5;
    call exp_by_squaring r2[0u32][3u32] r0 r1 into r6;
    call exp_by_squaring r2[0u32][4u32] r0 r1 into r7;
    call exp_by_squaring r2[0u32][5u32] r0 r1 into r8;
    call exp_by_squaring r2[0u32][6u32] r0 r1 into r9;
    call exp_by_squaring r2[0u32][7u32] r0 r1 into r10;
    call exp_by_squaring r2[0u32][8u32] r0 r1 into r11;
    call exp_by_squaring r2[0u32][9u32] r0 r1 into r12;
    call exp_by_squaring r2[0u32][10u32] r0 r1 into r13;
    call exp_by_squaring r2[0u32][11u32] r0 r1 into r14;
    call exp_by_squaring r2[0u32][12u32] r0 r1 into r15;
    call exp_by_squaring r2[0u32][13u32] r0 r1 into r16;
    cast r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 r16 into r17 as [u128; 14u32];
    call exp_by_squaring r2[1u32][0u32] r0 r1 into r18;
    call exp_by_squaring r2[1u32][1u32] r0 r1 into r19;
    call exp_by_squaring r2[1u32][2u32] r0 r1 into r20;
    call exp_by_squaring r2[1u32][3u32] r0 r1 into r21;
    call exp_by_squaring r2[1u32][4u32] r0 r1 into r22;
    call exp_by_squaring r2[1u32][5u32] r0 r1 into r23;
    call exp_by_squaring r2[1u32][6u32] r0 r1 into r24;
    call exp_by_squaring r2[1u32][7u32] r0 r1 into r25;
    call exp_by_squaring r2[1u32][8u32] r0 r1 into r26;
    call exp_by_squaring r2[1u32][9u32] r0 r1 into r27;
    call exp_by_squaring r2[1u32][10u32] r0 r1 into r28;
    call exp_by_squaring r2[1u32][11u32] r0 r1 into r29;
    call exp_by_squaring r2[1u32][12u32] r0 r1 into r30;
    call exp_by_squaring r2[1u32][13u32] r0 r1 into r31;
    cast r18 r19 r20 r21 r22 r23 r24 r25 r26 r27 r28 r29 r30 r31 into r32 as [u128; 14u32];
    cast r17 r32 into r33 as [[u128; 14u32]; 2u32];
    output r33 as [[u128; 14u32]; 2u32].private;

function decrypt_card:
    input r0 as u128.private;
    input r1 as u128.private;
    input r2 as u128.private;
    call exp_by_squaring r2 r0 r1 into r3;
    output r3 as u128.private;

function test_encrypt_exp_by_squaring:
    input r0 as u128.public;
    input r1 as u128.private;
    input r2 as u128.private;
    input r3 as u128.private;
    call exp_by_squaring r0 r1 r3 into r4;
    call exp_by_squaring r4 r2 r3 into r5;
    assert.eq r0 r5;
    output r4 as u128.private;
    output r5 as u128.private;

function test_exp_by_squaring:
    input r0 as u128.public;
    input r1 as u128.private;
    input r2 as u128.private;
    input r3 as u128.private;
    call exp_by_squaring r0 r1 r3 into r4;
    call exp_by_squaring r4 r2 r3 into r5;
    output r4 as u128.private;
    output r5 as u128.private;

constructor:
    assert.eq edition 0u16;
